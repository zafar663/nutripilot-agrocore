// core/calc/CORE_CALC_NUTRIENTS.cjs
"use strict";

/**
 * calcNutrients(items, ingredientsDB, opts?)
 *
 * Backward compatible:
 * - If opts is missing, uses the original CORE keys:
 *   ["me","cp","lys","met","thr","ca","avp","na"]
 *
 * Enhanced:
 * - If opts.keys is provided (array), computes exactly those keys.
 * - Properly handles null/undefined nutrient values (treated as missing, NOT 0).
 * - Returns:
 *   {
 *     ...nutrients,
 *     unknown: [...],
 *     coverage: {
 *       <key>: { present: n, missing: n, nonzero: n, supported: true/false }
 *     }
 *   }
 *
 * Key rule (IMPORTANT):
 * - supported = true if at least one ingredient has a PRESENT value for that key
 *   (i.e., not null/undefined). Zero is a valid numeric value and still counts as "present".
 * - This prevents nutrients from being skipped just because their computed sum is 0.
 */

function calcNutrients(items, ingredientsDB, opts = {}) {
  const defaultKeys = ["me", "cp", "lys", "met", "thr", "ca", "avp", "na"];

  const keys = Array.isArray(opts.keys) && opts.keys.length ? opts.keys : defaultKeys;

  const out = {};
  for (const k of keys) out[k] = 0;

  const unknown = [];

  // Coverage tracker per nutrient
  const coverage = {};
  for (const k of keys) {
    coverage[k] = {
      present: 0,   // value existed and was numeric (including 0)
      missing: 0,   // null/undefined/empty/non-numeric
      nonzero: 0,   // numeric and != 0 (debug)
      supported: false
    };
  }

  for (const it of items || []) {
    const ingredientName = it?.ingredient;
    const inclusion = Number(it?.inclusion ?? 0);

    if (!ingredientName || !Number.isFinite(inclusion)) continue;

    // Direct lookup (aliasing/normalization should happen upstream)
    const ing = ingredientsDB ? ingredientsDB[ingredientName] : null;

    if (!ing) {
      unknown.push({
        ingredient: ingredientName,
        dbKey: ingredientName,
        has_dbKey: Boolean(
          ingredientsDB &&
          Object.prototype.hasOwnProperty.call(ingredientsDB, ingredientName)
        ),
        inclusion
      });
      continue;
    }

    for (const k of keys) {
      const raw = ing[k];

      // Missing if null/undefined/empty string
      if (raw === null || raw === undefined || raw === "") {
        coverage[k].missing += 1;
        continue;
      }

      const v = Number(raw);
      if (!Number.isFinite(v)) {
        coverage[k].missing += 1;
        continue;
      }

      coverage[k].present += 1;
      if (v !== 0) coverage[k].nonzero += 1;

      out[k] += (inclusion * v) / 100;
    }
  }

  // supported logic: PRESENT (not null/undefined), not NONZERO
  for (const k of keys) {
    coverage[k].supported = coverage[k].present > 0;
  }

  // Stable rounding
  for (const k of keys) out[k] = Number(out[k].toFixed(4));

  out.unknown = unknown;
  out.coverage = coverage;
  return out;
}

module.exports = { calcNutrients };
