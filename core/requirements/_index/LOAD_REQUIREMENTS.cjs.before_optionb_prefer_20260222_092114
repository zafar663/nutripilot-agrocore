// core/db/requirements/_index/LOAD_REQUIREMENTS.cjs
"use strict";

const fs = require("fs");
const path = require("path");

function safePathResolve(...parts) {
  // NP_SAFE_PATH_RESOLVE_v1
  // Prevents path.resolve(undefined) crash; preserves behavior for normal strings.
  return path.resolve(...parts.map((p) => (p == null ? "" : String(p))));
}

function readJson(p) {
  const s = fs.readFileSync(p, "utf-8").replace(/^\uFEFF/, "");
  return JSON.parse(s);
}
function readJsonIfExists(p) {
  try {
    if (!fs.existsSync(p)) return null;
    return readJson(p);
  } catch (_) {
    return null;
  }
}
function safeLower(s) {
  return String(s || "").trim().toLowerCase();
}
function normalizeToken(s) {
  return safeLower(s).replace(/\s+/g, "_").replace(/[^a-z0-9_]+/g, "_");
}

function loadLegacyIndex(baseDir) {
  const indexPath = path.join(baseDir, "_index", "requirements.index.v1.json");
  const idx = readJsonIfExists(indexPath);
  return { idx, indexPath };
}
function loadAliases(baseDir) {
  const aliasPath = path.join(baseDir, "_index", "requirements.aliases.v1.json");
  const aliases = readJsonIfExists(aliasPath) || {};
  return { aliases, aliasPath };
}
function applyAlias(mapObj, rawValue) {
  const v0 = String(rawValue ?? "").trim();
  if (!v0) return "";
  const key = safeLower(v0);
  if (mapObj && Object.prototype.hasOwnProperty.call(mapObj, key)) return mapObj[key];

  const norm = normalizeToken(v0);
  if (mapObj && Object.prototype.hasOwnProperty.call(mapObj, norm)) return mapObj[norm];
  return norm;
}
function buildKey({ species, type, breed, region, version }) {
  return `${normalizeToken(species)}/${normalizeToken(type)}/${normalizeToken(breed)}/${normalizeToken(region)}/${normalizeToken(version)}`;
}

// Legacy vendor format: phases[]
function pickPhaseLegacy(reqDoc, phase) {
  const phases = Array.isArray(reqDoc?.phases) ? reqDoc.phases : [];
  if (!phases.length) return null;
  const wanted = normalizeToken(phase || "");
  if (!wanted) return phases[0];
  const hit = phases.find((p) => normalizeToken(p?.phase) === wanted);
  return hit || phases[0];
}
function toRequirementsMapLegacy(phaseObj) {
  const out = {};
  if (!phaseObj || typeof phaseObj !== "object") return out;
  for (const [k, v] of Object.entries(phaseObj)) {
    if (k === "phase" || k === "age_days" || k === "_meta") continue;
    const num = Number(v);
    if (Number.isFinite(num)) out[k] = num;
  }
  return out;
}

/**
 * Extract numeric targets from a candidate object.
 * Returns {} if nothing numeric found.
 */
function extractNumericTargets(obj) {
  const out = {};
  if (!obj || typeof obj !== "object") return out;
  for (const [k, v] of Object.entries(obj)) {
    const num = Number(v);
    if (Number.isFinite(num)) out[k] = num;
  }
  return out;
}

/**
 * Try to interpret different library schemas into a merged numeric target map.
 * Supported:
 * - lib.profiles.generic.targets_by_phase[phase]
 * - lib.targets_by_phase[phase]
 * - lib.targets (numeric flat object)
 * - lib.nutrient_targets (numeric flat object)
 * - plus optional generic/prof overrides when present
 */
function resolveTargetsFromLibrary({ libObj, breedKey, phaseKey }) {
  if (!libObj || typeof libObj !== "object") return {};

  // Schema A (preferred): profiles.generic.targets_by_phase[phase]
  const profiles = libObj.profiles && typeof libObj.profiles === "object" ? libObj.profiles : null;
  if (profiles) {
    const generic = profiles["generic"] || {};
    const prof = profiles[breedKey] || {};

    const genericPhase =
      generic?.targets_by_phase && generic.targets_by_phase[phaseKey]
        ? generic.targets_by_phase[phaseKey]
        : null;

    const merged = Object.assign(
      {},
      genericPhase || {},
      generic?.targets_override || {},
      prof?.targets_override || {}
    );

    const req = extractNumericTargets(merged);
    if (Object.keys(req).length) return req;
  }

  // Schema B: top-level targets_by_phase[phase]
  if (libObj.targets_by_phase && typeof libObj.targets_by_phase === "object") {
    const phaseObj = libObj.targets_by_phase[phaseKey] || libObj.targets_by_phase["starter"];
    const req = extractNumericTargets(phaseObj);
    if (Object.keys(req).length) return req;
  }

  // Schema C: flat numeric objects
  if (libObj.targets && typeof libObj.targets === "object") {
    const req = extractNumericTargets(libObj.targets);
    if (Object.keys(req).length) return req;
  }
  if (libObj.nutrient_targets && typeof libObj.nutrient_targets === "object") {
    const req = extractNumericTargets(libObj.nutrient_targets);
    if (Object.keys(req).length) return req;
  }

  return {};
}

/**
 * Recursively list files under a directory (safe: ignores permission errors).
 * NOTE: used only as a last-resort fallback when exact phase file is missing.
 */
function listFilesRecursive(rootDir) {
  const out = [];
  const stack = [rootDir];

  while (stack.length) {
    const cur = stack.pop();
    let entries = [];
    try {
      entries = fs.readdirSync(cur, { withFileTypes: true });
    } catch (_) {
      continue;
    }
    for (const e of entries) {
      const full = path.join(cur, e.name);
      if (e.isDirectory()) stack.push(full);
      else if (e.isFile()) out.push(full);
    }
  }
  return out;
}

/**
 * Find a phase JSON anywhere under:
 * core/db/requirements/poultry/<type>/
 * Preference order:
 * 1) exact .../v1/<region>/<phase>.json (current behavior)
 * 2) any file named "<phase>.json" under the <type> subtree
 * 3) if phase not found, no result.
 */
function findPhaseFileSmart({ baseDir, typeToken, regionToken, phaseToken }) {
  // 1) exact (current)
  const exact = path.join(baseDir, "poultry", typeToken, "v1", regionToken, `${phaseToken}.json`);
  if (fs.existsSync(exact)) return exact;

  // 2) scan anywhere under poultry/<type> for a matching filename
  const typeRoot = path.join(baseDir, "poultry", typeToken);
  if (!fs.existsSync(typeRoot)) return null;

  const wantName = `${phaseToken}.json`.toLowerCase();
  const files = listFilesRecursive(typeRoot);

  const hits = files.filter((p) => path.basename(p).toLowerCase() === wantName);
  if (!hits.length) return null;

  const prefer = hits
    .map((p) => ({ p, score: scorePhaseCandidate(p, regionToken) }))
    .sort((a, b) => b.score - a.score);

  return prefer[0].p;
}

function scorePhaseCandidate(p, regionToken) {
  const s = p.replace(/\\/g, "/").toLowerCase();
  let score = 0;
  if (s.includes("/v1/")) score += 5;
  if (regionToken && s.includes(`/${regionToken.toLowerCase()}/`)) score += 5;
  if (s.includes("/poultry/")) score += 1;
  return score;
}

// -------- Option-B (index+library) --------
function resolveOptionB({ baseDir, type, production, breed, phase, region }) {
  const t = normalizeToken(type);
  const prod = normalizeToken(production);
  const b = normalizeToken(breed || "generic");
  const ph = normalizeToken(phase || "starter");
  const reg = normalizeToken(region || "us");

  // Slot: core/db/requirements/poultry/<type>/v1/requirements.index.poultry.<type>.v1.json
  // IMPORTANT: This can be either:
  //  A) a WRAPPER (productions[prod] => { index_file, library_file })
  //  B) a CANONICAL INDEX (productions[prod] => { breeds: { ... } })
  const wrapPath = path.join(baseDir, "poultry", t, "v1", `requirements.index.poultry.${t}.v1.json`);
  const wrap = readJsonIfExists(wrapPath);

  let indexPath = null;
  let libPath = null;
  let indexObj = null;
  let libObj = null;

  // ---- Detect canonical index vs wrapper pointers ----
  const prodSlot = wrap && wrap.productions && wrap.productions[prod] ? wrap.productions[prod] : null;
  const slotLooksLikePointers =
    prodSlot &&
    typeof prodSlot === "object" &&
    (typeof prodSlot.index_file === "string" || typeof prodSlot.library_file === "string");

  const slotLooksLikeIndex =
    prodSlot &&
    typeof prodSlot === "object" &&
    (prodSlot.breeds || prodSlot.map);

  // --- BACKCOMPAT: "index-content stored in wrapper slot" ---
  // Old index formats (no productions)
  const looksLikeIndexContentOld =
    wrap &&
    typeof wrap === "object" &&
    (wrap.breeds || wrap.map || wrap.defaults) &&
    !wrap.productions &&
    !wrap.index_file &&
    !wrap.library_file;

  // NEW: canonical index with productions (your current state)
  const looksLikeIndexContentWithProductions =
    wrap &&
    typeof wrap === "object" &&
    wrap.productions &&
    typeof wrap.productions === "object" &&
    !!prodSlot &&
    slotLooksLikeIndex &&
    !slotLooksLikePointers;

  if (looksLikeIndexContentOld || looksLikeIndexContentWithProductions) {
    // Treat wrap as the index object.
    indexObj = wrap;
    indexPath = wrapPath;

    // Library is expected to sit beside the index file.
    const wrapDir = path.dirname(wrapPath);
    const preferredLib = `requirements.library.poultry.${t}.v1.json`;

    const preferredPath = path.join(wrapDir, preferredLib);
    if (fs.existsSync(preferredPath)) {
      libPath = preferredPath;
      libObj = readJsonIfExists(libPath);
    } else {
      // fallback: pick any json containing "library"
      const candidates = fs
        .readdirSync(wrapDir)
        .filter((n) => n.toLowerCase().endsWith(".json") && n.toLowerCase().includes("library"));
      const libName = candidates[0];
      if (libName) {
        libPath = path.join(wrapDir, libName);
        libObj = readJsonIfExists(libPath);
      }
    }

    if (!libObj) {
      return {
        ok: false,
        error: "REQUIREMENTS_OPTIONB_LIBRARY_MISSING",
        message: "Option-B index found but library file missing/unreadable beside it.",
        details: { wrapPath, indexPath, libPath }
      };
    }
  } else {
    // Normal wrapper with productions pointers
    if (slotLooksLikePointers) {
      indexPath = safePathResolve(path.dirname(wrapPath), prodSlot.index_file);
      libPath = safePathResolve(path.dirname(wrapPath), prodSlot.library_file);
    } else if (wrap?.index_file && wrap?.library_file) {
      // Backcompat: wrapper has direct index_file/library_file (no productions)
      indexPath = safePathResolve(path.dirname(wrapPath), wrap.index_file);
      libPath = safePathResolve(path.dirname(wrapPath), wrap.library_file);
    } else {
      // Direct fallback: core/db/requirements/poultry/<type>/<production>/
      const directDir = path.join(baseDir, "poultry", t, prod);
      const di = path.join(directDir, `index.poultry_${t}_${prod}.v1.json`);
      const dl = path.join(directDir, `library.poultry_${t}_${prod}.v1.json`);
      if (fs.existsSync(di) && fs.existsSync(dl)) {
        indexPath = di;
        libPath = dl;
      }
    }

    if (!indexPath || !libPath || !fs.existsSync(indexPath) || !fs.existsSync(libPath)) {
      return {
        ok: false,
        error: "REQUIREMENTS_OPTIONB_NOT_FOUND",
        message: `Option-B requirements not found for poultry/${t}/${prod}. Missing index/library.`,
        details: { wrapPath, indexPath, libPath }
      };
    }

    indexObj = readJsonIfExists(indexPath);
    libObj = readJsonIfExists(libPath);

    if (!indexObj || !libObj) {
      return {
        ok: false,
        error: "REQUIREMENTS_OPTIONB_FILES_UNREADABLE",
        message: "Option-B index/library unreadable",
        details: { indexPath, libPath }
      };
    }
  }

  if (!indexObj) {
    return {
      ok: false,
      error: "REQUIREMENTS_OPTIONB_INDEX_MISSING",
      message: "Option-B index object could not be loaded.",
      details: { wrapPath, indexPath, libPath }
    };
  }

  // --- Index structure support ---
  // Case 1: canonical index => indexObj.productions[prod].breeds
  // Case 2: legacy index => indexObj.map OR indexObj.breeds
  const canonicalSlot = indexObj?.productions && indexObj.productions[prod] ? indexObj.productions[prod] : null;
  const breedsMap =
    (canonicalSlot && (canonicalSlot.breeds || canonicalSlot.map)) ||
    indexObj?.map ||
    indexObj?.breeds ||
    {};

  const defaults = indexObj?.defaults || {};
  const defaultBreed = normalizeToken(defaults?.breed || "generic");
  const defaultPhase = normalizeToken(defaults?.phase || "starter");

  const breedKey = breedsMap[b]
    ? b
    : breedsMap[defaultBreed]
      ? defaultBreed
      : breedsMap["generic"]
        ? "generic"
        : Object.keys(breedsMap)[0];

  const phasesMap = breedKey ? breedsMap[breedKey] : null;

  if (!phasesMap || typeof phasesMap !== "object") {
    return {
      ok: false,
      error: "REQUIREMENTS_OPTIONB_INDEX_INVALID",
      message: "Option-B index missing (breeds|map)[breed][phase]",
      details: {
        indexPath: indexPath || wrapPath,
        breedKey,
        hasBreeds: !!indexObj?.breeds || !!canonicalSlot?.breeds,
        hasMap: !!indexObj?.map || !!canonicalSlot?.map,
        prod
      }
    };
  }

  const reqKey =
    phasesMap[ph] ||
    phasesMap[defaultPhase] ||
    phasesMap["starter"] ||
    Object.values(phasesMap)[0];

  if (!reqKey) {
    return {
      ok: false,
      error: "REQUIREMENTS_OPTIONB_REQKEY_MISSING",
      message: "Option-B index could not resolve reqKey",
      details: { indexPath: indexPath || wrapPath, breedKey, phase: ph, prod }
    };
  }

  // ---------- Library merge (preferred) ----------
  let requirements = resolveTargetsFromLibrary({ libObj, breedKey, phaseKey: ph });

  // ---------- SMART FALLBACK (phase JSON files anywhere under poultry/<type>) ----------
  if (!Object.keys(requirements).length) {
    const phaseFile = findPhaseFileSmart({ baseDir, typeToken: t, regionToken: reg, phaseToken: ph });
    const phaseDoc = phaseFile ? readJsonIfExists(phaseFile) : null;

    if (phaseDoc && typeof phaseDoc === "object") {
      requirements = extractNumericTargets(phaseDoc);

      if (Object.keys(requirements).length) {
        return {
          ok: true,
          reqKey,
          requirements,
          breed: breedKey,
          phase: ph,
          source: {
            mode: "option_b_fallback_phase_file",
            wrapPath,
            indexPath: indexPath || wrapPath,
            libPath: libPath || null,
            phaseFile
          },
          doc_meta: phaseDoc?._LOCK || phaseDoc?._meta || null
        };
      }
    }

    return {
      ok: false,
      error: "REQUIREMENTS_PHASE_EMPTY",
      message:
        "Option-B resolved reqKey but targets are empty: library schema missing/empty and phase fallback file not found/empty.",
      reqKey,
      details: {
        libPath: libPath || null,
        breedKey,
        phase: ph,
        triedExactPhaseFile: path.join(baseDir, "poultry", t, "v1", reg, `${ph}.json`),
        triedSmartPhaseSearchUnder: path.join(baseDir, "poultry", t),
        prod
      }
    };
  }

  return {
    ok: true,
    reqKey,
    requirements,
    breed: breedKey,
    phase: ph,
    source: { mode: "option_b", wrapPath, indexPath: indexPath || wrapPath, libPath: libPath || null },
    doc_meta: libObj?._LOCK || libObj?._meta || null
  };
}

function loadRequirementsProfile(input = {}) {
  const baseDir = path.join(__dirname, ".."); // core/db/requirements
  const { idx, indexPath } = loadLegacyIndex(baseDir);
  const { aliases, aliasPath } = loadAliases(baseDir);

  const species = applyAlias(aliases?.species, input.species || "poultry");
  const type = applyAlias(aliases?.type, input.type || "broiler");
  const breed = applyAlias(aliases?.breed, input.breed || "ross_308");
  const region = applyAlias(aliases?.region, input.region || "global");
  const version = applyAlias(aliases?.version, input.version || "v2025");
  const phase = input.phase || "starter";
  const production = input.production || "";

  // A) Legacy vendor index
  if (idx && Array.isArray(idx.entries)) {
    const key = buildKey({ species, type, breed, region, version });
    const match = idx.entries.find((e) => e && e.key === key);
    if (match?.path) {
      const reqFilePath = path.join(baseDir, match.path);
      const doc = readJsonIfExists(reqFilePath);
      if (!doc) {
        return {
          ok: false,
          error: "REQUIREMENTS_FILE_UNREADABLE",
          message: `Requirements file not readable: ${reqFilePath}`,
          key,
          reqFilePath
        };
      }
      const phaseObj = pickPhaseLegacy(doc, phase);
      if (!phaseObj) {
        return {
          ok: false,
          error: "REQUIREMENTS_EMPTY",
          message: `Requirements file has no phases[]: ${reqFilePath}`,
          key,
          reqFilePath
        };
      }
      const requirements = toRequirementsMapLegacy(phaseObj);
      if (!Object.keys(requirements).length) {
        return {
          ok: false,
          error: "REQUIREMENTS_PHASE_EMPTY",
          message: `Phase found but no numeric keys: ${reqFilePath}`,
          key,
          reqFilePath,
          phase: phaseObj?.phase || phase
        };
      }
      return {
        ok: true,
        reqKey: key,
        reqFilePath,
        species,
        type,
        breed,
        region,
        version,
        phase: phaseObj?.phase || phase,
        requirements,
        doc_meta: doc?._meta || null
      };
    }
  }

  // B) Option-B for poultry + v1
  if (normalizeToken(species) === "poultry" && normalizeToken(version) === "v1") {
    if (!String(production || "").trim()) {
      return {
        ok: false,
        error: "REQUIREMENTS_NEEDS_PRODUCTION",
        message: "Option-B V1 requires input.production (meat/layer/breeder).",
        meta: { species, type, breed, region, version, phase }
      };
    }

    const ob = resolveOptionB({ baseDir, type, production, breed, phase, region });
    if (ob.ok) {
      return {
        ok: true,
        reqKey: ob.reqKey,
        reqFilePath: ob.source?.indexPath || null,
        species,
        type: normalizeToken(type),
        breed: ob.breed,
        region,
        version,
        phase: ob.phase,
        requirements: ob.requirements,
        doc_meta: ob.doc_meta || null,
        source: ob.source || null
      };
    }

    return Object.assign(
      { species, type: normalizeToken(type), breed, region, version, phase, production },
      ob
    );
  }

  return {
    ok: false,
    error: "REQUIREMENTS_PROFILE_NOT_FOUND",
    message: "No requirements profile found in legacy index, and Option-B not applicable.",
    meta: { species, type, breed, region, version, phase, production },
    indexPath,
    aliasPath
  };
}

// --- Robust exports (supports all calling styles) ---
module.exports = loadRequirementsProfile;
module.exports.loadRequirementsProfile = loadRequirementsProfile;
module.exports.loadRequirements = loadRequirementsProfile; // back-compat
module.exports.default = loadRequirementsProfile;