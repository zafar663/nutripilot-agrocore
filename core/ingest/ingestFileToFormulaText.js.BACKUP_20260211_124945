// core/ingest/ingestFileToFormulaText.js
import pdf from "pdf-parse";
import { excelToFormulaText } from "./excelToFormulaText.js";

const BAD_NAMES = new Set(["poor","low","non-abbr","values","min","max","target","actual"]);
const INGEST_VERSION = "pdf_report_ratio_v4_2026-02-11";

function normalizeRawText(rawText){
  return String(rawText||"")
    .replace(/\r/g,"\n")
    .replace(/\u00A0/g," ")
    .replace(/[ \t]+/g," ")
    .trim();
}
function normalizeLines(rawText){
  return normalizeRawText(rawText).split("\n").map(l=>l.trim()).filter(Boolean);
}
function toNum(s){
  const n = Number(String(s).trim().replace(/,/g,""));
  return Number.isFinite(n) ? n : NaN;
}
function cleanKey(s){
  return String(s||"").toLowerCase().replace(/[^a-z0-9\- %]/g," ").replace(/\s+/g," ").trim();
}
function median(nums){
  const a = nums.filter(x=>Number.isFinite(x)).slice().sort((x,y)=>x-y);
  if(!a.length) return NaN;
  const mid = Math.floor(a.length/2);
  return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2;
}
function buildFormulaTextFromRows(rows){
  const cleaned = rows.map(r=>({
    ing: String(r.ing||"").replace(/\s+/g," ").trim(),
    pct: toNum(r.pct),
  })).filter(r=>r.ing && Number.isFinite(r.pct) && r.pct>0);

  if(cleaned.length<2) return { formula_text:"", cleaned:[], total:0 };
  const total = cleaned.reduce((a,r)=>a+r.pct,0);
    return { formula_text: cleaned.map(r=>`${r.ing} ${r.pct}`).join("\n"), cleaned, total };
}
function finalize(rows, meta){
  const built = buildFormulaTextFromRows(rows);
  if(!built.formula_text) return null;

  const warnings = [];
  let confidence = "medium";
  if(built.cleaned.length>=6 && built.total>=90 && built.total<=110) confidence="high";
  else warnings.push(`PDF parse: total ${built.total.toFixed(2)} (will be normalized later).`);

  return { formula_text: built.formula_text, confidence, warnings,
    meta: { version: INGEST_VERSION, ...meta, rows: built.cleaned.length, total: built.total }
  };
}
function joinCodeOnlyLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    const cur=lines[i];
    if(/^\d{1,3}$/.test(cur) && i+1<lines.length){ out.push(${cur} ); i++; continue; }
    out.push(cur);
  }
  return out;
}
// Robust split: find numeric blob by two glued decimals (e.g. 27.45274.57...)
function splitNameAndBlob(rest){
  const compact = String(rest||"").replace(/\s+/g,"");
  const re = /\d+\.\d{2,4}\d+\.\d{1,4}/;
  const m = re.exec(compact);
  if(!m) return null;
  const idx = m.index;
  const namePart = compact.slice(0,idx);
  const blob = compact.slice(idx);
  const name = namePart.replace(/([a-zA-Z])(\d)/g," ").replace(/\s+/g," ").trim();
  return { name, blob };
}
function bestPctWeightSplit(glued, ratioTarget){
  const s = String(glued||"").replace(/,/g,"").replace(/\s+/g,"");
  if(!/^\d/.test(s)) return null;
  if((s.match(/\./g)||[]).length < 2) return null;

  const candidates=[];
  const firstDot=s.indexOf(".");
  if(firstDot===-1) return null;

  for(const pctDec of [2,3,4]){
    const pctEnd=firstDot+1+pctDec;
    if(pctEnd>=s.length-3) continue;

    const pctStr=s.slice(0,pctEnd);
    const rest=s.slice(pctEnd);
    const restDot=rest.indexOf(".");
    if(restDot===-1) continue;

    for(const wDec of [1,2,3,4]){
      const wEnd=restDot+1+wDec;
      if(wEnd>rest.length) continue;

      const wStr=rest.slice(0,wEnd);
      const pct=toNum(pctStr);
      const w=toNum(wStr);

      if(!Number.isFinite(pct)||!Number.isFinite(w)) continue;
      if(pct<=0||pct>60) continue;
      if(w<=0||w>8000) continue;

      const ratio=w/pct;
      const score=Math.abs(ratio-ratioTarget);
      candidates.push({ pct, w, ratio, score });
    }
  }
  if(!candidates.length) return null;
  candidates.sort((a,b)=>a.score-b.score);
  return candidates[0];
}
function parsePdf_ReportByRatio(lines){
  const joined = joinCodeOnlyLines(lines);

  const rawRows=[];
  for(const line of joined){
    if(/^total\b/i.test(line)) break;

    const m = String(line).match(/^(\d{1,3})\s+(.*)$/);
    const rest0 = m ? m[2] : String(line);

    const split = splitNameAndBlob(rest0);
    if(!split) continue;

    const name = split.name;
    const glued = split.blob;

    if(!name) continue;
    const key = cleanKey(name);
    if(BAD_NAMES.has(key)) continue;
    if(key.startsWith("=>")) continue;

    rawRows.push({ name, glued });
  }
  if(rawRows.length<6) return null;

  const pass1=[];
  for(const r of rawRows){
    const best=bestPctWeightSplit(r.glued,10);
    if(!best) continue;
    pass1.push({ ing:r.name, pct:best.pct, ratio:best.ratio });
  }
  if(pass1.length<6) return null;

  const ratioMed = median(pass1.map(x=>x.ratio));
  if(!Number.isFinite(ratioMed)||ratioMed<3||ratioMed>200) return null;

  const tol=0.40;
  const kept=[];
  for(const r of rawRows){
    const best=bestPctWeightSplit(r.glued,ratioMed);
    if(!best) continue;
    const ratio=best.w/best.pct;
    if(Math.abs(ratio-ratioMed)/ratioMed>tol) continue;

    const k=cleanKey(r.name);
    if((k.length<=2 || ["dm","me","cp","ee","cf","ash","nfe","deb","ca","cl","na","k"].includes(k)) && !k.includes("%")) continue;

    kept.push({ ing:r.name, pct:best.pct });
  }
  if(kept.length<6) return null;

  return finalize(kept, { mode:"pdf_report_ratio", ratioMedian:ratioMed, kept:kept.length, scanned:rawRows.length, lines:lines.length });
}
function parsePdf_SimplePairs(lines){
  const rows=[];
  for(const cur of lines){
    if(/^total\b/i.test(cur)) break;
    const m = String(cur).match(/^(.+?)\s+(-?\d+(?:\.\d+)?)$/);
    if(!m) continue;

    const ing=m[1].trim();
    const pct=m[2].trim();
    if(BAD_NAMES.has(cleanKey(ing))) continue;

    rows.push({ ing, pct });
  }
  return finalize(rows, { mode:"pdf_simple_pairs", lines:lines.length });
}
function parsePdfToFormulaText(rawText){
  const lines = normalizeLines(rawText);

  const report = parsePdf_ReportByRatio(lines);
  if(report) return report;

  const simple = parsePdf_SimplePairs(lines);
  if(simple) return simple;

  const preview = normalizeRawText(rawText).slice(0,900);
  return { formula_text:"", confidence:"low",
    warnings:["PDF parse failed: could not reconstruct ingredient/percent rows."],
    meta:{ version: INGEST_VERSION, mode:"pdf_failed", preview }
  };
}
export async function ingestFileToFormulaText(fileBuffer, fileInfo={}){
  const filename = String(fileInfo.filename||"");
  const contentType = String(fileInfo.contentType||"");

  if(contentType.includes("spreadsheet") || filename.toLowerCase().endsWith(".xlsx")){
    return await excelToFormulaText(fileBuffer);
  }

  if(contentType.includes("pdf") || filename.toLowerCase().endsWith(".pdf")){
    try{
      const parsed = await pdf(fileBuffer);
      return parsePdfToFormulaText(String(parsed?.text||""));
    }catch(err){
      return { formula_text:"", confidence:"low",
        warnings:[PDF extract error: ],
        meta:{ version: INGEST_VERSION, mode:"pdf_error" }
      };
    }
  }

  try{
    const txt = Buffer.from(fileBuffer).toString("utf8");
    const t = String(txt||"").trim();
    return { formula_text:t, confidence: t ? "medium":"low", warnings: t ? []:["Text ingest produced empty output."],
      meta:{ version: INGEST_VERSION, mode:"text_utf8" }
    };
  }catch(err){
    return { formula_text:"", confidence:"low",
      warnings:[Text decode error: ],
      meta:{ version: INGEST_VERSION, mode:"text_error" }
    };
  }
}
